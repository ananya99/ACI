# @package _global_

defaults:
  # Below is how you specify the default animal configurations. These are not actually
  # used in the experiment, but define the default configurations for different aspects
  # of the animals. When loading an animal and/or writing a config, you can refer to
  # these defaults using the following:
  # - /env/animals/${env/animals}@_here_
  # This will set all defaults in the current config to the ones specified in
  # ${env/animals}. You can then overwrite these defaults to implement the desired
  # animal configuration. The same idea applies with eyes and optics.
  - /env/animals: animal
  - /env/animals/eyes: eye
  - /env/animals/eyes/optics: optics

  # Simular to mazes, you must also specify the object configuration.
  - /env/objects: object

  # NOTE: there is a bug in OmegaConf that doesn't allow optional dataclass objects
  # that are inherited to be specified via the defaults list. For instance,
  # if you have the following structured configs:
  #
  # @dataclass
  # class A:
  #   a: Optional[int] = None
  #
  # @dataclass
  # class B(A):
  #   pass
  #
  # And you define B in a config file where you specify it's config group such that
  # OmegaConf thinks it's a structured config, a will always be None unless you
  # explicitly set it in B. Like if you set a default value to it in A, that won't carry
  # over to B. This is the case for renderer since it's Optional. Therefore, we define
  # it here rather than the env config.
  - /env/renderer: bev

trainer:
  callbacks:
    eval_callback:
      # Set the number of eval episodes to the number of mazes in the eval env
      # NOTE: \$ is used to escape the interpolation so that it's not evaluated
      # until the callback is called. This is because eval_env may not be defined
      # when this config is loaded.
      n_eval_episodes: \${eval_env.n_eval_episodes}
